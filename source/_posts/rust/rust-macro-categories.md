---
title: Rust 中的宏分类
date: 2024-12-15 23:49:06
tags: [Rust, 宏]
categories: Rust
description:
cover:
permalink:
---

Rust中的宏可以按照不同的标准进行分类，以下是一些常见的分类方式及具体介绍：

### 按功能用途分类

- **声明宏**：用于定义新的语法结构或对已有语法进行扩展，通过`macro_rules!`关键字定义。例如，`vec!`宏用于方便地创建`Vec`类型的数组，`println!`宏用于格式化输出到控制台。
- **过程宏**：在编译时对代码进行操作和转换，比声明宏更强大，可以访问更多的编译器内部信息。包括以下三种类型：
    - **自定义派生宏**：允许为结构体和枚举自动实现特定的 trait。比如，为一个结构体派生`Debug` trait时，使用`#[derive(Debug)]`，编译器会在编译阶段自动为该结构体生成`Debug` trait的实现代码。
    - **属性宏**：可以为代码添加自定义属性，用于修改代码的行为或为代码生成额外的代码。例如，`#[test]`属性宏用于标记一个函数为测试函数，测试框架会在运行测试时自动执行被标记的函数。
    - **函数宏**：类似于函数调用，但可以在编译时对传入的参数进行处理和转换，然后生成新的代码。例如`format_args!`宏，它接受格式化字符串和参数，在编译时将其转换为合适的代码来处理格式化输出。

### 按定义位置分类

- **内置宏**：Rust语言自带的宏，如`vec!`、`println!`、`panic!`等，无需额外引入即可使用，提供了一些基本的功能，方便开发者进行日常的编程工作。
- **外部宏**：由外部 crate提供的宏，需要在`Cargo.toml`文件中添加相应的依赖后才能使用。例如，`serde`库中的`#[derive(Serialize, Deserialize)]`宏，用于方便地实现结构体的序列化和反序列化。
- **用户自定义宏**：由开发者自己定义的宏，用于满足特定的编程需求。可以根据实际情况定义声明宏或过程宏，以提高代码的复用性和可读性。

### 按调用方式分类

- **零参数宏**：不需要传入任何参数的宏，如`panic!`宏，通常用于在程序出现错误时立即终止程序并打印错误信息。
- **固定参数宏**：需要传入固定数量参数的宏，如`format!`宏，它需要传入一个格式化字符串和对应的参数，用于生成格式化后的字符串。
- **可变参数宏**：可以传入可变数量参数的宏，如`println!`宏，它可以根据需要传入不同数量的参数进行格式化输出。
